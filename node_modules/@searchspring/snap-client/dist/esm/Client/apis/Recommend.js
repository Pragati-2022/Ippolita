import { API } from './Abstract';
import { AppMode, charsParams } from '@searchspring/snap-toolbox';
class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.reject = reject;
            this.resolve = resolve;
        });
    }
}
const BATCH_TIMEOUT = 150;
export class RecommendAPI extends API {
    constructor(config) {
        super(config);
        this.batches = {};
    }
    async getProfile(queryParameters) {
        const headerParameters = {};
        const response = await this.request({
            path: '/api/personalized-recommendations/profile.json',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, '/api/personalized-recommendations/profile.json' + JSON.stringify(queryParameters));
        return response;
    }
    async batchRecommendations(parameters) {
        // set up batch key and deferred promises
        const key = parameters.batched ? parameters.siteId : `${Math.random()}`;
        const batch = (this.batches[key] = this.batches[key] || { timeout: null, request: { tags: [], limits: [] }, entries: [] });
        const deferred = new Deferred();
        // add each request to the list
        batch.entries.push({ request: parameters, deferred: deferred });
        // wait for all of the requests to come in
        window.clearTimeout(batch.timeout);
        batch.timeout = window.setTimeout(async () => {
            // delete the batch so a new one can take its place
            delete this.batches[key];
            // reorder the requests by order value in context.
            batch.entries.sort(sortBatchEntries);
            // now that the requests are in proper order, map through them
            // and build out the batches
            batch.entries.map((entry) => {
                const { tags, categories, ...otherParams } = entry.request;
                let limits = entry.request.limits;
                if (!limits) {
                    limits = 20;
                }
                const [tag] = tags || [];
                delete otherParams.batched; // remove from request parameters
                delete otherParams.order; // remove from request parameters
                delete otherParams.limits;
                batch.request.tags.push(tag);
                if (categories) {
                    if (!batch.request.categories) {
                        batch.request.categories = Array.isArray(categories) ? categories : [categories];
                    }
                    else {
                        batch.request.categories = batch.request.categories.concat(categories);
                    }
                }
                batch.request.limits = batch.request.limits.concat(limits);
                batch.request = { ...batch.request, ...otherParams };
            });
            try {
                if (this.configuration.mode == AppMode.development) {
                    batch.request.test = true;
                }
                let response;
                if (charsParams(batch.request) > 1024) {
                    if (batch.request['product']) {
                        batch.request['product'] = batch.request['product'].toString();
                    }
                    response = await this.postRecommendations(batch.request);
                }
                else {
                    response = await this.getRecommendations(batch.request);
                }
                batch.entries?.forEach((entry, index) => {
                    entry.deferred.resolve([response[index]]);
                });
            }
            catch (err) {
                batch.entries?.forEach((entry) => {
                    entry.deferred.reject(err);
                });
            }
        }, BATCH_TIMEOUT);
        return deferred.promise;
    }
    async getRecommendations(queryParameters) {
        const headerParameters = {};
        const siteId = queryParameters.siteId;
        const path = `/boost/${siteId}/recommend`;
        const response = await this.request({
            path,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, path + JSON.stringify(queryParameters));
        return response;
    }
    async postRecommendations(requestParameters) {
        const headerParameters = {};
        headerParameters['Content-Type'] = 'application/json';
        const siteId = requestParameters.siteId;
        const path = `/boost/${siteId}/recommend`;
        const response = await this.request({
            path,
            method: 'POST',
            headers: headerParameters,
            body: requestParameters,
        }, path + JSON.stringify(requestParameters));
        return response;
    }
}
function sortBatchEntries(a, b) {
    // undefined order goes last
    if (a.request.order == undefined && b.request.order == undefined) {
        return 0;
    }
    if (a.request.order == undefined && b.request.order != undefined) {
        return 1;
    }
    if (b.request.order == undefined && a.request.order != undefined) {
        return -1;
    }
    if (a.request.order < b.request.order) {
        return -1;
    }
    if (a.request.order > b.request.order) {
        return 1;
    }
    return 0;
}
