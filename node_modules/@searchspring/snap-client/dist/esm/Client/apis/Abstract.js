import deepmerge from 'deepmerge';
import { AppMode } from '@searchspring/snap-toolbox';
import { fibonacci } from '../utils/fibonacci';
import { NetworkCache } from '../NetworkCache/NetworkCache';
const isBlob = (value) => typeof Blob !== 'undefined' && value instanceof Blob;
export class API {
    constructor(configuration) {
        this.configuration = configuration;
        this.retryDelay = 1000;
        this.retryCount = 0;
        this.cache = new NetworkCache(this.configuration.cache);
    }
    get mode() {
        return this.configuration.mode;
    }
    async request(context, cacheKey) {
        const { url, init } = this.createFetchParams(context);
        if (cacheKey) {
            const cachedResponse = this.cache.get(cacheKey);
            if (cachedResponse) {
                this.retryCount = 0; // reset count and delay incase rate limit occurs again before a page refresh
                this.retryDelay = 1000;
                return cachedResponse;
            }
        }
        let response;
        let responseJSON;
        try {
            response = await this.fetchApi(url, init);
            responseJSON = await response?.json();
            if (response.status >= 200 && response.status < 300) {
                this.retryCount = 0; // reset count and delay incase rate limit occurs again before a page refresh
                this.retryDelay = 1000;
                if (cacheKey) {
                    // save in the cache before returning
                    this.cache.set(cacheKey, responseJSON);
                }
                return responseJSON;
            }
            else if (response.status == 429) {
                if (this.retryCount < this.configuration.maxRetry) {
                    await new Promise((resolve) => setTimeout(resolve, this.retryDelay)); // delay retry
                    this.retryDelay = fibonacci(this.retryCount) * 1000;
                    this.retryCount++;
                    throw new Error('Rate limited.');
                }
                else {
                    throw new Error('Retry rate limit exceeded.');
                }
            }
            else if (response.status == 404 && responseJSON?.message == 'Profile is currently paused') {
                //dont throw if profile is paused.
                throw new Error(`${responseJSON.message}: ${context.query?.tag}`);
            }
            throw new Error('Unexpected Response Status.');
        }
        catch (err) {
            if (err.message == 'Rate limited.') {
                return await this.request(context, cacheKey);
            }
            // throw an object with fetch details
            throw { err, fetchDetails: { status: response?.status, message: response?.statusText || 'FAILED', url, ...init } };
        }
    }
    createFetchParams(context) {
        // grab siteID out of context to generate apiHost fo URL
        const siteId = context?.body?.siteId || context?.query?.siteId;
        if (!siteId) {
            throw new Error(`Request failed. Missing "siteId" parameter.`);
        }
        const siteIdHost = `https://${siteId}.a.searchspring.io`;
        const origin = (this.configuration.origin || siteIdHost).replace(/\/$/, '');
        let url = `${origin}/${context.path.replace(/^\//, '')}`;
        // merging globals to request query
        const combinedQuery = deepmerge(context.query || {}, this.configuration.globals);
        if (Object.keys(combinedQuery).length !== 0) {
            // only add the querystring to the URL if there are query parameters.
            url += '?' + this.configuration.queryParamsStringify(combinedQuery);
        }
        // merging globals to request body
        const body = (typeof FormData !== 'undefined' && context.body instanceof FormData) || context.body instanceof URLSearchParams || isBlob(context.body)
            ? context.body
            : JSON.stringify(context.body ? deepmerge(context.body, this.configuration.globals) : context.body);
        const headers = { ...this.configuration.headers, ...context.headers };
        const init = {
            method: context.method,
            headers: headers,
            body,
        };
        return { url, init };
    }
    async fetchApi(url, init) {
        const response = await this.configuration.fetchApi(url, init);
        return response;
    }
}
export class ApiConfiguration {
    constructor(config = {}) {
        this.config = config;
        if (!config.maxRetry) {
            this.config.maxRetry = 8;
        }
        this.config.cache = this.config.cache || {};
        this.config.mode = this.config.mode || AppMode.production;
        if (this.config.mode == AppMode.development) {
            this.config.cache.enabled = false;
        }
    }
    get cache() {
        return this.config?.cache || {};
    }
    get maxRetry() {
        return this.config.maxRetry || 8;
    }
    get origin() {
        return this.config.origin || '';
    }
    get fetchApi() {
        return this.config.fetchApi || window.fetch.bind(window);
    }
    get queryParamsStringify() {
        return this.config.queryParamsStringify || querystring;
    }
    get headers() {
        return this.config.headers || {};
    }
    set headers(newHeaders) {
        this.config.headers = newHeaders;
    }
    get globals() {
        return this.config.globals || {};
    }
    set globals(newGlobals) {
        this.config.globals = newGlobals;
    }
    get mode() {
        return this.config.mode;
    }
}
export function querystring(params, prefix = '') {
    return Object.keys(params)
        .map((key) => {
        const fullKey = prefix + (prefix.length ? `[${key}]` : key);
        const value = params[key];
        if (value instanceof Array) {
            const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
            return `${encodeURIComponent(fullKey)}=${multiValue}`;
        }
        if (value instanceof Date) {
            return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
        }
        if (value instanceof Object) {
            return querystring(value, fullKey);
        }
        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
    })
        .filter((part) => part.length > 0)
        .join('&');
}
