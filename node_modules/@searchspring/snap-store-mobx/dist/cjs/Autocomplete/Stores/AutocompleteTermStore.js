"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Term = exports.AutocompleteTermStore = void 0;
var mobx_1 = require("mobx");
var AutocompleteTermStore = /** @class */ (function (_super) {
    __extends(AutocompleteTermStore, _super);
    function AutocompleteTermStore(services, autocomplete, paginationData, search, resetTerms, rootState, config) {
        var _a, _b;
        var suggestions = __spreadArray([], ((autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.alternatives) ? autocomplete.alternatives : []).map(function (term) { return term.text; }), true);
        if ((_a = config.settings) === null || _a === void 0 ? void 0 : _a.integratedSpellCorrection) {
            if ((autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.correctedQuery) && (search === null || search === void 0 ? void 0 : search.query) && autocomplete.correctedQuery.toLowerCase() != search.query.toLowerCase()) {
                // the query was corrected
                suggestions.unshift(autocomplete.correctedQuery);
            }
            (search === null || search === void 0 ? void 0 : search.query) && suggestions.unshift(search.query);
        }
        else {
            if ((_b = autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.suggested) === null || _b === void 0 ? void 0 : _b.text) {
                // a suggestion for query
                suggestions.unshift(autocomplete.suggested.text);
            }
            else if ((autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.correctedQuery) && paginationData.totalResults) {
                // the query was corrected
                suggestions.unshift(autocomplete.correctedQuery);
            }
            else if ((autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.query) && paginationData.totalResults) {
                // there were no suggestions or corrections,
                suggestions.unshift(autocomplete === null || autocomplete === void 0 ? void 0 : autocomplete.query);
            }
        }
        var terms = [];
        suggestions.map(function (term, index) {
            return terms.push(new Term(services, {
                active: index === 0,
                value: term,
            }, terms, resetTerms, rootState));
        });
        return _super.apply(this, terms) || this;
    }
    Object.defineProperty(AutocompleteTermStore, Symbol.species, {
        get: function () {
            return Array;
        },
        enumerable: false,
        configurable: true
    });
    return AutocompleteTermStore;
}(Array));
exports.AutocompleteTermStore = AutocompleteTermStore;
var Term = /** @class */ (function () {
    function Term(services, term, terms, resetTerms, rootState) {
        var _this = this;
        var _a;
        this.active = term.active;
        this.value = term.value;
        this.url = (_a = services === null || services === void 0 ? void 0 : services.urlManager) === null || _a === void 0 ? void 0 : _a.set({ query: this.value });
        this.preview = function () {
            var _a;
            resetTerms();
            terms.map(function (term) {
                term.active = false;
            });
            _this.active = true;
            rootState.locks.terms.lock();
            rootState.locks.facets.unlock();
            (_a = _this.url) === null || _a === void 0 ? void 0 : _a.set({ query: _this.value }).go();
        };
        (0, mobx_1.makeObservable)(this, {
            active: mobx_1.observable,
            value: mobx_1.observable,
        });
    }
    return Term;
}());
exports.Term = Term;
