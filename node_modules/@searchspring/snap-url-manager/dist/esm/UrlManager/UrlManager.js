import Immutable from 'seamless-immutable';
class WatcherPool {
    constructor() {
        this.callbacks = [];
        // nothing to do here
    }
    subscribe(cb) {
        this.callbacks.push(cb);
        return () => (this.callbacks = this.callbacks.filter((_cb) => _cb != cb));
    }
    notify() {
        this.callbacks.forEach((cb) => cb());
    }
}
export class UrlManager {
    constructor(translator, linker, globalState, localState, watcherPool, omissions = [], detached) {
        this.linker = linker;
        this.omissions = omissions;
        this.detached = detached;
        this.urlState = Immutable({});
        this.globalState = Immutable({});
        this.localState = Immutable({});
        this.mergedState = Immutable({});
        this.localState = Immutable(localState || {});
        this.globalState = Immutable(globalState || {});
        this.translator = translator;
        // set globals based on urlRoot of translator config when serializeUrlRoot is set
        const translatorConfig = this.getTranslatorConfig();
        if (translatorConfig.urlRoot && translatorConfig.settings?.serializeUrlRoot) {
            this.globalState = this.globalState.merge(Immutable(this.translator.deserialize(translatorConfig.urlRoot)), {
                deep: true,
                merger: arrayConcatMerger,
            });
        }
        if (watcherPool) {
            this.watcherPool = watcherPool;
        }
        else {
            this.watcherPool = new WatcherPool();
            if (this.translator.bindExternalEvents instanceof Function) {
                this.translator.bindExternalEvents(() => this.watcherPool.notify());
            }
        }
        this.subscribe(() => {
            this.refresh();
        });
        this.refresh();
    }
    without(obj, fullPath, values) {
        // TODO: refactor - find way to remove updateNode function
        const path = fullPath.slice(0, -1);
        const lastKey = fullPath[fullPath.length - 1];
        if (!path.length) {
            if (!values?.length) {
                return obj.without(lastKey);
            }
            return updateNode(lastKey, obj);
        }
        if (!obj.getIn(path)) {
            return obj;
        }
        return obj.updateIn(path, (node) => {
            return updateNode(lastKey, node);
        });
        function updateNode(key, node) {
            if (node[lastKey] === undefined) {
                return node;
            }
            if (node[lastKey] instanceof Array) {
                if (!values || !values.length) {
                    return node.without(lastKey);
                }
                return node.set(lastKey, node[lastKey].filter((value) => {
                    return !values.some((removeValue) => {
                        return compareObjects(value, removeValue);
                    });
                }));
            }
            if (typeof node == 'object') {
                return node.without(lastKey);
            }
            return node;
        }
    }
    getTranslatorUrl() {
        if (this.detached) {
            return this.detached.url;
        }
        return this.translator.getCurrentUrl();
    }
    refresh() {
        this.prevState = this.mergedState;
        this.urlState = this.omissions.reduce((state, om) => {
            return this.without(state, om.path, om.values);
        }, Immutable(this.translator.deserialize(this.getTranslatorUrl())));
        this.mergedState = this.globalState.merge(this.urlState, {
            deep: true,
            merger: arrayConcatMerger,
        });
        this.mergedState = this.mergedState.merge(this.localState, {
            deep: true,
            merger: arrayConcatMerger,
        });
    }
    get state() {
        return this.mergedState;
    }
    unpackPathAndState(stateOrPath, _state) {
        const path = stateOrPath instanceof Array ? stateOrPath : typeof stateOrPath == 'string' ? stateOrPath.split('.') : [];
        const state = !(stateOrPath instanceof Array) && typeof stateOrPath == 'object' ? stateOrPath : _state === undefined ? {} : _state;
        return { path, state };
    }
    set(...args) {
        const { path, state } = this.unpackPathAndState(args[0], args[1]);
        const newState = path.length ? this.localState.setIn(path, removeArrayDuplicates(state)) : removeArrayDuplicates(state);
        const omissions = removeArrayDuplicates(this.omissions.concat(path.length ? { path } : Object.keys(this.urlState).map((key) => ({ path: [key] }))));
        return new UrlManager(this.translator, this.linker, this.globalState, newState, this.watcherPool, omissions, this.detached);
    }
    merge(...args) {
        const { path, state } = this.unpackPathAndState(args[0], args[1]);
        const newState = path.length
            ? this.localState.updateIn(path, (oldState) => {
                if (oldState instanceof Array) {
                    const newValues = Array.isArray(state) ? state : [state];
                    return removeArrayDuplicates(oldState.concat(newValues));
                }
                else if (typeof oldState == 'object') {
                    if (Array.isArray(state)) {
                        return state.length ? removeArrayDuplicates([oldState].concat(state)) : oldState;
                    }
                    else {
                        return oldState.merge(state, { deep: true, merger: arrayConcatMerger });
                    }
                }
                else if (typeof oldState != 'undefined') {
                    // not an object or array
                    const newValues = (Array.isArray(state) ? state : [state]).filter((value) => !compareObjects(value, oldState));
                    return newValues.length ? removeArrayDuplicates([oldState].concat(newValues)) : oldState;
                }
                else if (typeof oldState == 'undefined') {
                    const urlState = this.urlState.getIn(path);
                    if (urlState instanceof Array && !Array.isArray(state)) {
                        return [state];
                    }
                }
                return state;
            })
            : this.localState.merge(state, { deep: true, merger: arrayConcatMerger });
        return new UrlManager(this.translator, this.linker, this.globalState, newState, this.watcherPool, this.omissions, this.detached);
    }
    remove(_path, values) {
        const { path } = this.unpackPathAndState(_path, {});
        values = typeof values != 'undefined' ? (values instanceof Array ? values : [values]) : [];
        const without = this.without(this.localState, path, values);
        const omissions = removeArrayDuplicates(this.omissions.concat({ path, values: values }));
        return new UrlManager(this.translator, this.linker, this.globalState, without, this.watcherPool, omissions, this.detached);
    }
    reset() {
        // reset detached url
        if (this.detached) {
            this.detached.url = '';
        }
        return new UrlManager(this.translator, this.linker, this.globalState, {}, this.watcherPool, Object.keys(this.urlState).map((k) => ({ path: [k] })), this.detached);
    }
    withConfig(config) {
        if (config instanceof Function) {
            config = config(this.translator.getConfig());
        }
        return new UrlManager(new (Object.getPrototypeOf(this.translator).constructor)(config), this.linker, this.globalState, this.localState, this.watcherPool, this.omissions, this.detached);
    }
    withGlobals(globals) {
        this.globalState = this.globalState.merge(Immutable(globals), {
            deep: true,
            merger: arrayConcatMerger,
        });
        return new UrlManager(this.translator, this.linker, this.globalState, this.localState, this.watcherPool, this.omissions, this.detached);
    }
    getTranslatorConfig() {
        return this.translator.getConfig();
    }
    get href() {
        return this.translator.serialize(this.state);
    }
    go(config) {
        if (this.detached) {
            this.detached.url = this.href;
        }
        else {
            this.translator.go(this.href, config);
        }
        this.watcherPool.notify();
    }
    detach(reset = false) {
        return new UrlManager(this.translator, this.linker, this.globalState, this.localState, new WatcherPool(), this.omissions, {
            url: reset ? '' : this.getTranslatorUrl(),
        });
    }
    get link() {
        if (!this.linker) {
            return {};
        }
        return this.linker(this);
    }
    subscribe(cb) {
        return this.watcherPool.subscribe(() => {
            const prevState = this.prevState;
            const state = this.mergedState;
            cb(prevState, state);
        });
    }
}
function removeArrayDuplicates(array) {
    if (Array.isArray(array) && array.length) {
        return array.reduce((accu, item) => {
            if (!accu.some((keep) => compareObjects(keep, item))) {
                accu.push(item);
            }
            return accu;
        }, [array[0]]);
    }
    return array;
}
function arrayConcatMerger(current, other) {
    if (current instanceof Array && other instanceof Array) {
        return removeArrayDuplicates([...current, ...other]);
    }
}
function compareObjects(obj1, obj2) {
    if (!obj1 && !obj2) {
        return true;
    }
    else if ((!obj1 && obj2) || (obj1 && !obj2)) {
        return false;
    }
    const primitives = ['string', 'number', 'boolean', 'undefined'];
    const typeA = typeof obj1;
    const typeB = typeof obj2;
    if (typeA !== typeB)
        return false;
    if (primitives.includes(typeA))
        return obj1 === obj2;
    const isArrayA = Array.isArray(obj1);
    const isArrayB = Array.isArray(obj2);
    if (isArrayA !== isArrayB) {
        return false;
    }
    if (isArrayA) {
        // compare arrays
        if (obj1.length != obj2.length)
            return false;
        for (let i = 0; i < obj1.length; i++) {
            if (!compareObjects(obj1[i], obj2[i])) {
                return false;
            }
        }
    }
    else {
        // compare object keys
        if (!compareObjects(Object.keys(obj1).sort(), Object.keys(obj2).sort())) {
            return false;
        }
        // compare object values
        let result = true;
        Object.keys(obj1).forEach((key) => {
            if (!compareObjects(obj1[key], obj2[key])) {
                result = false;
            }
        });
        return result;
    }
    return true;
}
