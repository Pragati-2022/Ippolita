import { useState, useEffect, useRef } from 'preact/hooks';
import { jsx, css } from '@emotion/react';
import classnames from 'classnames';
import { useTheme, CacheProvider } from '../../../providers';
export const FALLBACK_IMAGE_URL = '//cdn.searchspring.net/ajax_search/img/default_image.png';
const CSS = {
    image: ({ visibility }) => css({
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        height: 'auto',
        '& img': {
            visibility: visibility,
            flexShrink: '0',
            objectFit: 'contain',
            maxWidth: '100%',
            maxHeight: '100%',
        },
    }),
};
export function Image(properties) {
    const globalTheme = useTheme();
    const props = {
        // default props
        fallback: FALLBACK_IMAGE_URL,
        lazy: true,
        // global theme
        ...globalTheme?.components?.image,
        // props
        ...properties,
        ...properties.theme?.components?.image,
    };
    const { alt, src, fallback, hoverSrc, lazy, onMouseOver, onMouseOut, onError, onLoad, onClick, disableStyles, className, style } = props;
    const [visibility, setVisibility] = useState('hidden');
    const [isHovering, setHover] = useState(false);
    const prevSrcRef = useRef('');
    useEffect(() => {
        prevSrcRef.current = src;
    });
    if (prevSrcRef.current && prevSrcRef.current != src) {
        setVisibility('hidden');
    }
    const styling = {};
    if (!disableStyles) {
        styling.css = [CSS.image({ visibility }), style];
    }
    else if (style) {
        styling.css = [style];
    }
    return (jsx(CacheProvider, null,
        jsx("div", { ...styling, className: classnames('ss__image', className) },
            jsx("img", { src: (isHovering ? hoverSrc : src) || fallback, alt: alt, title: alt, loading: lazy ? 'lazy' : undefined, onLoad: (e) => {
                    setVisibility('visible');
                    onLoad && onLoad(e);
                }, onClick: (e) => onClick && onClick(e), onError: (e) => {
                    e.target.src = fallback || '';
                    onError && onError(e);
                }, onMouseOver: (e) => {
                    hoverSrc && setHover(true);
                    onMouseOver && onMouseOver(e);
                }, onMouseOut: (e) => {
                    hoverSrc && setHover(false);
                    onMouseOut && onMouseOut(e);
                } }))));
}
