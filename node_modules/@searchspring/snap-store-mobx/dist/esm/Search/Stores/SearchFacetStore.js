import deepmerge from 'deepmerge';
import { makeObservable, observable, action, computed, reaction } from 'mobx';
export class SearchFacetStore extends Array {
    static get [Symbol.species]() {
        return Array;
    }
    constructor(config, services, storage, facetsData = [], pagination = {}, meta, merchandising) {
        const facets = facetsData
            .filter((facet) => {
            const facetMeta = facet.field && meta.facets && meta.facets[facet.field];
            // exclude facets that have no meta data
            if (!facetMeta)
                return false;
            // exclude facets that have mismatched meta data
            if ((facetMeta.display == 'slider' && facet.type !== 'range') || (facet.type == 'range' && facetMeta.display !== 'slider')) {
                return false;
            }
            // trim facets - remove facets that have no use
            const facetConfig = config.settings?.facets?.fields && facet.field && config.settings?.facets?.fields[facet.field];
            const shouldTrim = typeof facetConfig?.trim == 'boolean' ? facetConfig.trim : config.settings?.facets?.trim;
            if (shouldTrim) {
                if (facet.type === 'range' &&
                    facet?.range?.low == facet?.range?.high) {
                    return false;
                }
                else if (facet.values?.length == 0) {
                    return false;
                }
                else if (!facet.filtered && facet.values?.length == 1) {
                    if (merchandising?.content?.inline) {
                        return facet.values[0].count + merchandising.content?.inline.length != pagination.totalResults;
                    }
                    else {
                        return facet.values[0].count != pagination.totalResults;
                    }
                }
            }
            return true;
        })
            .map((facet) => {
            const facetMeta = facet.field && meta.facets && meta.facets[facet.field];
            const facetConfig = deepmerge({ ...config.settings?.facets, fields: undefined }, (config.settings?.facets?.fields && facet.field && config.settings?.facets?.fields[facet.field]) || {});
            delete facetConfig.fields;
            switch (facet.type) {
                case 'range':
                    return new RangeFacet(services, storage, facet, facetMeta || {}, facetConfig);
                case 'value':
                case 'range-buckets':
                default:
                    return new ValueFacet(services, storage, facet, facetMeta || {}, facetConfig);
            }
        });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        super(...facets);
    }
}
export class Facet {
    constructor(services, storage, facet, facetMeta, config) {
        this.filtered = false;
        this.custom = {};
        this.collapsed = false;
        this.display = '';
        this.label = '';
        this.services = services;
        this.storage = storage;
        Object.assign(this, facetMeta, facet);
        makeObservable(this, {
            type: observable,
            field: observable,
            filtered: observable,
            custom: observable,
            collapsed: observable,
            display: observable,
            label: observable,
            clear: computed,
            toggleCollapse: action,
        });
        const collapseData = this.storage.get(`facets.${this.field}.collapsed`);
        this.collapsed = collapseData ?? this.collapsed;
        if (this.filtered && this.collapsed && typeof collapseData == 'undefined' && config.autoOpenActive) {
            this.toggleCollapse();
        }
    }
    get clear() {
        return {
            url: this.services.urlManager.remove('page').remove(`filter.${this.field}`),
        };
    }
    toggleCollapse() {
        this.collapsed = !this.collapsed;
        this.storage.set(`facets.${this.field}.collapsed`, this.collapsed);
    }
}
export class RangeFacet extends Facet {
    constructor(services, storage, facet, facetMeta, config) {
        super(services, storage, facet, facetMeta, config);
        this.range = {
            low: 0,
            high: 0,
        };
        this.active = {
            low: 0,
            high: 0,
        };
        this.step = facet?.step;
        const storedRange = config.storeRange && this.storage.get(`facets.${this.field}.range`);
        if (storedRange && facet.filtered && (facet.range?.low > storedRange.low || facet.range?.high < storedRange.high)) {
            // range from API has shrunk
            this.range = this.storage.get(`facets.${this.field}.range`);
        }
        else {
            this.storage.set(`facets.${this.field}.range`, facet.range);
            this.range = facet.range;
        }
        // TODO: Fix api
        // needed when API returns no active (only seems to be when range.low == range.high)
        this.active = facet.active || facet.range;
        this.formatSeparator = facetMeta?.formatSeparator || '-';
        this.formatValue = facetMeta?.formatValue || '%01.2f';
        makeObservable(this, {
            step: observable,
            range: observable,
            active: observable,
            formatSeparator: observable,
            formatValue: observable,
        });
    }
    get filteredCount() {
        return Number(this.filtered);
    }
}
export class ValueFacet extends Facet {
    constructor(services, storage, facet, facetMeta, config) {
        super(services, storage, facet, facetMeta, config);
        this.values = [];
        this.search = {
            input: '',
        };
        this.overflow = {
            enabled: false,
            limited: true,
            limit: 0,
            remaining: undefined,
            setLimit: function (limit) {
                if (limit != this.limit) {
                    this.enabled = true;
                    this.limit = limit;
                    this.calculate();
                }
            },
            toggle: (val) => {
                if (typeof val != 'undefined') {
                    this.overflow.limited = val;
                }
                else {
                    this.overflow.limited = !this.overflow.limited;
                }
                this.storage.set(`facets.${this.field}.overflow.limited`, this.overflow.limited);
                this.overflow.calculate();
            },
            calculate: () => {
                if (this.overflow.limit > 0) {
                    const remaining = this.values.length - this.overflow.limit;
                    if (remaining > 0 && !this.search.input) {
                        this.overflow.enabled = true;
                        if (this.overflow.limited) {
                            this.overflow.remaining = remaining;
                        }
                        else {
                            this.overflow.remaining = 0;
                        }
                    }
                    else {
                        this.overflow.enabled = false;
                    }
                }
            },
        };
        this.multiple = this.multiple;
        this.values =
            (facet.values &&
                facet.values.map((value) => {
                    switch (facet.type) {
                        case 'value':
                            if (facetMeta.display === 'hierarchy') {
                                const filteredValues = facet?.values?.filter((value) => value.filtered) || [];
                                return new FacetHierarchyValue(services, this, value, filteredValues);
                            }
                            else {
                                // converting values to strings to ensure UrlManager state matches state created from URL
                                value.value = value?.value?.toString();
                                return new FacetValue(services, this, value);
                            }
                        case 'range-buckets':
                            return new FacetRangeValue(services, this, value);
                    }
                })) ||
                [];
        if (config.pinFiltered && facetMeta.display !== 'hierarchy') {
            this.values.sort((a, b) => Number(b.filtered) - Number(a.filtered));
        }
        const overflowLimitedState = this.storage.get(`facets.${this.field}.overflow.limited`);
        if (typeof overflowLimitedState != 'undefined') {
            this.overflow.toggle(overflowLimitedState);
        }
        makeObservable(this, {
            values: observable,
            search: observable,
            multiple: observable,
            overflow: observable,
            refinedValues: computed,
        });
        reaction(() => this.search.input, () => {
            this.overflow.calculate();
        });
    }
    get filteredCount() {
        return this.values.filter((value) => value?.filtered).length;
    }
    get refinedValues() {
        let values = this.values || [];
        if (this.search.input) {
            const search = new RegExp(escapeRegExp(this.search.input), 'i');
            values = this.values.filter((value) => String(value?.label || '').match(search));
        }
        if (this.overflow.enabled && this.overflow.limited) {
            values = values.slice(0, this.overflow.limit);
        }
        return values;
    }
}
export class FacetValue {
    constructor(services, facet, value) {
        Object.assign(this, value);
        if (this.filtered) {
            this.url = services.urlManager.remove('page').remove(`filter.${facet.field}`, value.value);
        }
        else {
            let valueUrl = services.urlManager.remove('page');
            if (facet.multiple == 'single') {
                valueUrl = valueUrl?.remove(`filter.${facet.field}`);
            }
            this.url = valueUrl?.merge(`filter.${facet.field}`, value.value);
        }
    }
}
export class FacetHierarchyValue extends FacetValue {
    constructor(services, facet, value, filteredValues) {
        super(services, facet, value);
        this.level = 0;
        this.history = false;
        if (value.value && facet.hierarchyDelimiter) {
            this.level = value.value.split(facet.hierarchyDelimiter).length;
        }
        if (facet.filtered && filteredValues?.length) {
            const filteredLevel = facet?.hierarchyDelimiter && filteredValues[0].value?.split(facet.hierarchyDelimiter).length;
            if (filteredLevel && this.level <= filteredLevel) {
                this.history = true;
            }
        }
        if (value.value) {
            this.url = services.urlManager.remove('page').set(`filter.${facet.field}`, value.value);
        }
        else {
            this.url = services.urlManager.remove('page').remove(`filter.${facet.field}`);
        }
    }
}
export class FacetRangeValue {
    constructor(services, facet, value) {
        Object.assign(this, value);
        if (this.filtered) {
            this.url = services.urlManager.remove('page').remove(`filter.${facet.field}`, [{ low: this.low, high: this.high }]);
        }
        else {
            let valueUrl = services.urlManager.remove('page');
            if (facet.multiple == 'single') {
                valueUrl = valueUrl?.remove(`filter.${facet.field}`);
            }
            this.url = valueUrl?.merge(`filter.${facet.field}`, [{ low: this.low, high: this.high }]);
        }
    }
}
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
