import deepmerge from 'deepmerge';
import Immutable from 'seamless-immutable';
import { RangeValueProperties } from '../../types';
const defaultConfig = {
    urlRoot: '',
    queryParameter: 'q',
    settings: {
        serializeUrlRoot: true,
    },
};
export class QueryStringTranslator {
    constructor(config = {}) {
        this.config = Immutable(deepmerge(defaultConfig, config));
    }
    bindExternalEvents(update) {
        window.addEventListener('popstate', update);
    }
    getCurrentUrl() {
        return location.search || '';
    }
    getConfig() {
        return this.config.asMutable();
    }
    parseQueryString(queryString) {
        const justQueryString = queryString.split('?').pop() || '';
        return justQueryString
            .split('&')
            .filter((v) => v)
            .map((kvPair) => {
            const [key, value] = kvPair.split('=').map((v) => decodeURIComponent(v.replace(/\+/g, ' ')));
            return { key: key.split('.'), value };
        });
    }
    generateQueryString(params) {
        const root = this.config.urlRoot.includes('?')
            ? this.config.urlRoot.split('?')[0]
            : this.config.urlRoot.includes('#')
                ? this.config.urlRoot.split('#')[0]
                : this.config.urlRoot || window.location.pathname;
        const queryParamString = params.length
            ? '?' +
                params
                    .map((param) => {
                    return encodeURIComponent(param.key.join('.')) + '=' + encodeURIComponent(param.value);
                })
                    .join('&')
            : '';
        return `${root}${queryParamString}`;
    }
    parsePage(queryParams) {
        const pageParam = queryParams.find((param) => param.key.length == 1 && param.key[0] == 'page');
        if (!pageParam) {
            return {};
        }
        const page = Number(pageParam.value);
        return !isNaN(page) && page > 1 ? { page } : {};
    }
    parseSort(queryParams) {
        const sortParams = queryParams.filter((param) => param.key.length == 2 && param.key[0] == 'sort');
        if (!sortParams.length) {
            return {};
        }
        return {
            sort: sortParams.map((param) => ({
                field: param.key[1],
                direction: param.value,
            })),
        };
    }
    parseOther(queryParams, except = []) {
        const state = {};
        queryParams
            .filter((param) => except.indexOf(param.key[0]) == -1)
            .forEach((param) => {
            const path = param.key;
            const value = param.value;
            // eslint-disable-next-line prefer-const
            let node = state;
            path.forEach((key, i) => {
                const isLast = i == path.length - 1;
                if (isLast) {
                    node[key] = node[key] || [];
                    node[key].push(value);
                }
                else {
                    node[key] = node[key] || {};
                    node = node[key];
                }
            });
        });
        return state;
    }
    parseQuery(queryParams) {
        const qParamKey = this.getConfig().queryParameter;
        const qParam = queryParams.find((param) => param.key.length == 1 && param.key[0] == qParamKey);
        return qParam ? { query: qParam.value } : {};
    }
    parseFilter(queryParams) {
        const valueFilterParams = queryParams.filter((p) => p.key.length == 2 && p.key[0] == 'filter');
        const rangeFilterParams = queryParams.filter((p) => p.key.length == 3 && p.key[0] == 'filter');
        const valueFilters = valueFilterParams.reduce((state, param) => {
            const currentValue = (state.filter || {})[param.key[1]] || [];
            return {
                filter: {
                    ...state.filter,
                    [param.key[1]]: [...(Array.isArray(currentValue) ? currentValue : [currentValue]), param.value],
                },
            };
        }, {});
        const rangeFilters = rangeFilterParams.reduce((state, param, index) => {
            // ranges should come in pairs!
            // use index to build pairs, ignore non pairs
            // build set as encountered - only return full sets (low + high)
            let newState = state;
            const nextRangeParam = rangeFilterParams[index + 1];
            if (index % 2 == 0 &&
                nextRangeParam &&
                nextRangeParam.key[1] == param.key[1] &&
                param.key[2] == RangeValueProperties.LOW &&
                nextRangeParam.key[2] == RangeValueProperties.HIGH) {
                const currentValue = (state.filter || {})[param.key[1]] || [];
                newState = {
                    filter: {
                        ...state.filter,
                        [param.key[1]]: [
                            ...(Array.isArray(currentValue) ? currentValue : [currentValue]),
                            {
                                [RangeValueProperties.LOW]: +param.value || null,
                                [RangeValueProperties.HIGH]: +nextRangeParam.value || null,
                            },
                        ],
                    },
                };
            }
            return newState;
        }, {});
        return {
            ...(valueFilters.filter || rangeFilters.filter
                ? {
                    filter: {
                        ...valueFilters.filter,
                        ...rangeFilters.filter,
                    },
                }
                : {}),
        };
    }
    encodePage(state) {
        if (!state.page || state.page === 1) {
            return [];
        }
        return [{ key: ['page'], value: '' + state.page }];
    }
    encodeOther(state, except = []) {
        let params = [];
        const addRecursive = (obj, currentPath) => {
            Object.keys(obj).forEach((key) => {
                if (currentPath.length == 0 && except.indexOf(key) != -1) {
                    return;
                }
                const value = obj[key];
                if (value instanceof Array) {
                    params = params.concat(value.map((v) => {
                        return { key: [...currentPath, key], value: v };
                    }));
                }
                else if (typeof value == 'object') {
                    addRecursive(value, [...currentPath, key]);
                }
                else {
                    params = params.concat([{ key: [...currentPath, key], value }]);
                }
            });
        };
        addRecursive(state, []);
        return params;
    }
    encodeQuery(state) {
        if (!state.query) {
            return [];
        }
        return [
            {
                key: [this.getConfig().queryParameter],
                value: state.query,
            },
        ];
    }
    encodeSort(state) {
        if (!state.sort) {
            return [];
        }
        return (state.sort instanceof Array ? state.sort : [state.sort]).map((sort) => {
            return {
                key: ['sort', sort.field],
                value: sort.direction,
            };
        });
    }
    encodeFilter(state) {
        if (!state.filter) {
            return [];
        }
        return Object.keys(state.filter).flatMap((key) => {
            if (!state.filter || !state.filter[key]) {
                return [];
            }
            const filter = state.filter[key];
            return (filter instanceof Array ? filter : [filter]).flatMap((value) => {
                if (typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {
                    return [
                        {
                            key: ['filter', key],
                            value: '' + value,
                        },
                    ];
                }
                else if (typeof value == 'object' &&
                    typeof value[RangeValueProperties.LOW] != 'undefined' &&
                    typeof value[RangeValueProperties.HIGH] != 'undefined') {
                    return [
                        {
                            key: ['filter', key, RangeValueProperties.LOW],
                            value: '' + (value[RangeValueProperties.LOW] ?? '*'),
                        },
                        {
                            key: ['filter', key, RangeValueProperties.HIGH],
                            value: '' + (value[RangeValueProperties.HIGH] ?? '*'),
                        },
                    ];
                }
                return [];
            });
        });
    }
    queryParamsToState(queryParams) {
        // Todo: Special stage storage for sorts
        return {
            ...this.parseQuery(queryParams),
            ...this.parsePage(queryParams),
            ...this.parseFilter(queryParams),
            ...this.parseSort(queryParams),
            ...this.parseOther(queryParams, ['page', this.getConfig().queryParameter, 'filter', 'sort']),
        };
    }
    stateToQueryParams(state = {}) {
        return [
            ...this.encodeOther(state, ['page', 'query', 'filter', 'sort', this.getConfig().queryParameter]),
            ...this.encodeQuery(state),
            ...this.encodePage(state),
            ...this.encodeFilter(state),
            ...this.encodeSort(state),
        ];
    }
    serialize(state) {
        const queryParams = this.stateToQueryParams(state);
        return this.generateQueryString(queryParams);
    }
    deserialize(url) {
        const queryString = url.includes('?') ? (url.split('?').pop() || '').split('#').shift() || '' : '';
        const queryParams = this.parseQueryString(queryString);
        return this.queryParamsToState(queryParams);
    }
    go(url) {
        history.pushState(null, '', url);
    }
}
