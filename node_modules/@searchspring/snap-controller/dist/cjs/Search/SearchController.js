"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHrefSelector = exports.getStorableRequestParams = exports.SearchController = void 0;
var deepmerge_1 = __importDefault(require("deepmerge"));
var css_escape_1 = __importDefault(require("css.escape"));
var AbstractController_1 = require("../Abstract/AbstractController");
var snap_store_mobx_1 = require("@searchspring/snap-store-mobx");
var getParams_1 = require("../utils/getParams");
var types_1 = require("../types");
var API_LIMIT = 500;
var defaultConfig = {
    id: 'search',
    globals: {},
    settings: {
        redirects: {
            merchandising: true,
            singleResult: true,
        },
        facets: {
            trim: true,
            pinFiltered: true,
            storeRange: true,
            autoOpenActive: true,
        },
    },
};
var SearchController = /** @class */ (function (_super) {
    __extends(SearchController, _super);
    function SearchController(config, _a, context) {
        var client = _a.client, store = _a.store, urlManager = _a.urlManager, eventManager = _a.eventManager, profiler = _a.profiler, logger = _a.logger, tracker = _a.tracker;
        var _this = this;
        var _b, _c, _d;
        _this = _super.call(this, config, { client: client, store: store, urlManager: urlManager, eventManager: eventManager, profiler: profiler, logger: logger, tracker: tracker }, context) || this;
        _this.type = types_1.ControllerTypes.search;
        _this.previousResults = [];
        _this.track = {
            product: {
                click: function (e, result) {
                    var _a, _b;
                    var target = e.target;
                    var resultHref = (_a = result.mappings.core) === null || _a === void 0 ? void 0 : _a.url;
                    var elemHref = target === null || target === void 0 ? void 0 : target.getAttribute('href');
                    // the href that should be used for restoration - if the elemHref contains the resultHref - use resultHref
                    var storedHref = (elemHref === null || elemHref === void 0 ? void 0 : elemHref.indexOf(resultHref)) != -1 ? resultHref : elemHref || resultHref;
                    var scrollMap = {};
                    // generate the selector using element class and parent classes
                    var selector = generateHrefSelector(target, storedHref);
                    var domRect = selector ? (_b = document === null || document === void 0 ? void 0 : document.querySelector(selector)) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect() : undefined;
                    // store element position data to scrollMap
                    if (selector || storedHref || domRect) {
                        try {
                            var stringyParams = JSON.parse(_this.storage.get('lastStringyParams'));
                            var storableRequestParams = getStorableRequestParams(stringyParams);
                            var storableStringyParams = JSON.stringify(storableRequestParams);
                            scrollMap[storableStringyParams] = { domRect: domRect, href: storedHref, selector: selector };
                        }
                        catch (err) {
                            // failed to get lastStringParams
                            _this.log.warn('Failed to save scollMap!', err);
                        }
                    }
                    // store position data or empty object
                    _this.storage.set('scrollMap', scrollMap);
                    // track
                    var _c = result.attributes, intellisuggestData = _c.intellisuggestData, intellisuggestSignature = _c.intellisuggestSignature;
                    var event = _this.tracker.track.product.click({
                        intellisuggestData: intellisuggestData,
                        intellisuggestSignature: intellisuggestSignature,
                        href: elemHref || resultHref,
                    });
                    _this.eventManager.fire('track.product.click', { controller: _this, event: e, result: result, trackEvent: event });
                    return event;
                },
            },
        };
        _this.search = function () { return __awaiter(_this, void 0, void 0, function () {
            var params, err_1, stringyParams, prevStringyParams, searchProfile, meta_1, response_1, preventBackfill, dontBackfill, backfills, pageSize, meta_2, pagesNeeded, _a, backFillPageSize, backFillPages, i, backfillParams, backfillResults_1, backfillResponses, afterSearchProfile, err_2, afterStoreProfile, err_3, err_4;
            var _b, _c;
            var _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
            return __generator(this, function (_x) {
                switch (_x.label) {
                    case 0:
                        if (!!this.initialized) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.init()];
                    case 1:
                        _x.sent();
                        _x.label = 2;
                    case 2:
                        params = this.params;
                        if (((_e = (_d = this.params.search) === null || _d === void 0 ? void 0 : _d.query) === null || _e === void 0 ? void 0 : _e.string) && ((_g = (_f = this.params.search) === null || _f === void 0 ? void 0 : _f.query) === null || _g === void 0 ? void 0 : _g.string.length)) {
                            // save it to the history store
                            this.store.history.save(this.params.search.query.string);
                        }
                        _x.label = 3;
                    case 3:
                        _x.trys.push([3, 26, , 27]);
                        _x.label = 4;
                    case 4:
                        _x.trys.push([4, 6, , 7]);
                        return [4 /*yield*/, this.eventManager.fire('beforeSearch', {
                                controller: this,
                                request: params,
                            })];
                    case 5:
                        _x.sent();
                        return [3 /*break*/, 7];
                    case 6:
                        err_1 = _x.sent();
                        if ((err_1 === null || err_1 === void 0 ? void 0 : err_1.message) == 'cancelled') {
                            this.log.warn("'beforeSearch' middleware cancelled");
                            return [2 /*return*/];
                        }
                        else {
                            this.log.error("error in 'beforeSearch' middleware");
                            throw err_1;
                        }
                        return [3 /*break*/, 7];
                    case 7:
                        stringyParams = JSON.stringify(params);
                        prevStringyParams = this.storage.get('lastStringyParams');
                        if (stringyParams == prevStringyParams) {
                            // no param change - not searching
                            return [2 /*return*/];
                        }
                        searchProfile = this.profiler.create({ type: 'event', name: 'search', context: params }).start();
                        if (!(((_h = this.config.settings) === null || _h === void 0 ? void 0 : _h.infinite) && ((_j = params.pagination) === null || _j === void 0 ? void 0 : _j.page) && params.pagination.page > 1)) return [3 /*break*/, 15];
                        preventBackfill = ((_k = this.config.settings.infinite) === null || _k === void 0 ? void 0 : _k.backfill) && !this.store.results.length && params.pagination.page > this.config.settings.infinite.backfill;
                        dontBackfill = !((_l = this.config.settings.infinite) === null || _l === void 0 ? void 0 : _l.backfill) && !this.store.results.length;
                        // if the page is higher than the backfill setting redirect back to page 1
                        if (preventBackfill || dontBackfill) {
                            this.storage.set('scrollMap', {});
                            this.urlManager.set('page', 1).go();
                            return [2 /*return*/];
                        }
                        backfills = [];
                        pageSize = ((_m = params.pagination) === null || _m === void 0 ? void 0 : _m.pageSize) || this.store.pagination.pageSize || this.store.pagination.defaultPageSize;
                        if (!(((_o = this.config.settings) === null || _o === void 0 ? void 0 : _o.infinite.backfill) && !this.previousResults.length)) return [3 /*break*/, 10];
                        if (!!pageSize) return [3 /*break*/, 9];
                        return [4 /*yield*/, this.client.meta()];
                    case 8:
                        meta_2 = _x.sent();
                        pageSize = (_p = meta_2.pagination) === null || _p === void 0 ? void 0 : _p.defaultPageSize;
                        _x.label = 9;
                    case 9:
                        // restricting pageSize to the limit
                        pageSize = pageSize > API_LIMIT ? API_LIMIT : pageSize;
                        pagesNeeded = ((_q = params.pagination) === null || _q === void 0 ? void 0 : _q.page) && ((_r = params.pagination) === null || _r === void 0 ? void 0 : _r.page) > ((_s = this.config.settings) === null || _s === void 0 ? void 0 : _s.infinite.backfill)
                            ? (_t = this.config.settings) === null || _t === void 0 ? void 0 : _t.infinite.backfill
                            : (_u = params.pagination) === null || _u === void 0 ? void 0 : _u.page;
                        _a = backFillSize(pagesNeeded, pageSize), backFillPageSize = _a.size, backFillPages = _a.pages;
                        for (i = 1; i <= backFillPages; i++) {
                            backfillParams = (0, deepmerge_1.default)(__assign({}, params), { pagination: { pageSize: backFillPageSize, page: i } });
                            backfills.push(this.client.search(backfillParams));
                        }
                        _x.label = 10;
                    case 10:
                        if (!(backfills && backfills.length)) return [3 /*break*/, 12];
                        backfillResults_1 = [];
                        return [4 /*yield*/, Promise.all(backfills)];
                    case 11:
                        backfillResponses = _x.sent();
                        backfillResponses.map(function (_a) {
                            var metaBackfill = _a[0], responseBackfill = _a[1];
                            if (!meta_1) {
                                meta_1 = metaBackfill;
                            }
                            if (!response_1) {
                                response_1 = responseBackfill;
                            }
                            // push results to array
                            if (responseBackfill.results) {
                                backfillResults_1.push.apply(backfillResults_1, responseBackfill.results);
                            }
                        });
                        // overwrite pagination params to expected state
                        response_1.pagination.pageSize = pageSize;
                        response_1.pagination.totalPages = Math.ceil(response_1.pagination.totalResults / response_1.pagination.pageSize);
                        response_1.pagination.page = (_v = params.pagination) === null || _v === void 0 ? void 0 : _v.page;
                        // set the response results with results from backfill responses
                        response_1.results = backfillResults_1;
                        if (!response_1.meta) {
                            // @ts-ignore : MockClient will overwrite the client search() method and use SearchData to return mock data which already contains meta data
                            response_1.meta = meta_1;
                        }
                        return [3 /*break*/, 14];
                    case 12: return [4 /*yield*/, this.client.search(params)];
                    case 13:
                        // infinite with no backfills.
                        _b = _x.sent(), meta_1 = _b[0], response_1 = _b[1];
                        // @ts-ignore : MockClient will overwrite the client search() method and use SearchData to return mock data which already contains meta data
                        if (!response_1.meta) {
                            // @ts-ignore : MockClient will overwrite the client search() method and use SearchData to return mock data which already contains meta data
                            response_1.meta = meta_1;
                        }
                        //append new results to previous results
                        response_1.results = __spreadArray(__spreadArray([], this.previousResults, true), (response_1.results || []), true);
                        _x.label = 14;
                    case 14: return [3 /*break*/, 17];
                    case 15: return [4 /*yield*/, this.client.search(params)];
                    case 16:
                        //standard.
                        _c = _x.sent(), meta_1 = _c[0], response_1 = _c[1];
                        // @ts-ignore : MockClient will overwrite the client search() method and use SearchData to return mock data which already contains meta data
                        if (!response_1.meta) {
                            // @ts-ignore : MockClient will overwrite the client search() method and use SearchData to return mock data which already contains meta data
                            response_1.meta = meta_1;
                        }
                        _x.label = 17;
                    case 17:
                        searchProfile.stop();
                        this.log.profile(searchProfile);
                        afterSearchProfile = this.profiler.create({ type: 'event', name: 'afterSearch', context: params }).start();
                        _x.label = 18;
                    case 18:
                        _x.trys.push([18, 20, , 21]);
                        return [4 /*yield*/, this.eventManager.fire('afterSearch', {
                                controller: this,
                                request: params,
                                response: response_1,
                            })];
                    case 19:
                        _x.sent();
                        return [3 /*break*/, 21];
                    case 20:
                        err_2 = _x.sent();
                        if ((err_2 === null || err_2 === void 0 ? void 0 : err_2.message) == 'cancelled') {
                            this.log.warn("'afterSearch' middleware cancelled");
                            afterSearchProfile.stop();
                            return [2 /*return*/];
                        }
                        else {
                            this.log.error("error in 'afterSearch' middleware");
                            throw err_2;
                        }
                        return [3 /*break*/, 21];
                    case 21:
                        afterSearchProfile.stop();
                        this.log.profile(afterSearchProfile);
                        // store previous results for infinite usage
                        if ((_w = this.config.settings) === null || _w === void 0 ? void 0 : _w.infinite) {
                            this.previousResults = JSON.parse(JSON.stringify(response_1.results));
                        }
                        // update the store
                        this.store.update(response_1);
                        afterStoreProfile = this.profiler.create({ type: 'event', name: 'afterStore', context: params }).start();
                        _x.label = 22;
                    case 22:
                        _x.trys.push([22, 24, , 25]);
                        return [4 /*yield*/, this.eventManager.fire('afterStore', {
                                controller: this,
                                request: params,
                                response: response_1,
                            })];
                    case 23:
                        _x.sent();
                        return [3 /*break*/, 25];
                    case 24:
                        err_3 = _x.sent();
                        if ((err_3 === null || err_3 === void 0 ? void 0 : err_3.message) == 'cancelled') {
                            this.log.warn("'afterStore' middleware cancelled");
                            afterStoreProfile.stop();
                            return [2 /*return*/];
                        }
                        else {
                            this.log.error("error in 'afterStore' middleware");
                            throw err_3;
                        }
                        return [3 /*break*/, 25];
                    case 25:
                        afterStoreProfile.stop();
                        this.log.profile(afterStoreProfile);
                        return [3 /*break*/, 27];
                    case 26:
                        err_4 = _x.sent();
                        if (err_4) {
                            if (err_4.err && err_4.fetchDetails) {
                                switch (err_4.fetchDetails.status) {
                                    case 429: {
                                        this.store.error = {
                                            code: 429,
                                            type: snap_store_mobx_1.ErrorType.WARNING,
                                            message: 'Too many requests try again later',
                                        };
                                        break;
                                    }
                                    case 500: {
                                        this.store.error = {
                                            code: 500,
                                            type: snap_store_mobx_1.ErrorType.ERROR,
                                            message: 'Invalid Search Request or Service Unavailable',
                                        };
                                        break;
                                    }
                                    default: {
                                        this.store.error = {
                                            type: snap_store_mobx_1.ErrorType.ERROR,
                                            message: err_4.err.message,
                                        };
                                        break;
                                    }
                                }
                                this.log.error(this.store.error);
                                this.handleError(err_4.err, err_4.fetchDetails);
                            }
                            else {
                                this.store.error = {
                                    type: snap_store_mobx_1.ErrorType.ERROR,
                                    message: "Something went wrong... - ".concat(err_4),
                                };
                                this.log.error(err_4);
                                this.handleError(err_4);
                            }
                            this.store.loading = false;
                        }
                        return [3 /*break*/, 27];
                    case 27: return [2 /*return*/];
                }
            });
        }); };
        // deep merge config with defaults
        _this.config = (0, deepmerge_1.default)(defaultConfig, _this.config);
        // set restorePosition to be enabled by default when using infinite (if not provided)
        if (((_b = _this.config.settings) === null || _b === void 0 ? void 0 : _b.infinite) && typeof _this.config.settings.restorePosition == 'undefined') {
            _this.config.settings.restorePosition = { enabled: true };
        }
        _this.store.setConfig(_this.config);
        _this.storage = new snap_store_mobx_1.StorageStore({
            type: snap_store_mobx_1.StorageType.SESSION,
            key: "ss-controller-".concat(_this.config.id),
        });
        // set last params to undefined for compare in search
        _this.storage.set('lastStringyParams', undefined);
        // add 'beforeSearch' middleware
        _this.eventManager.on('beforeSearch', function (search, next) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        search.controller.store.loading = true;
                        return [4 /*yield*/, next()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        // add 'afterSearch' middleware
        _this.eventManager.on('afterSearch', function (search, next) { return __awaiter(_this, void 0, void 0, function () {
            var config, redirectURL, searchStore, nonBackgroundFilters;
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            return __generator(this, function (_q) {
                switch (_q.label) {
                    case 0:
                        config = search.controller.config;
                        redirectURL = (_b = (_a = search.response) === null || _a === void 0 ? void 0 : _a.merchandising) === null || _b === void 0 ? void 0 : _b.redirect;
                        searchStore = search.controller.store;
                        if (redirectURL && ((_d = (_c = config === null || config === void 0 ? void 0 : config.settings) === null || _c === void 0 ? void 0 : _c.redirects) === null || _d === void 0 ? void 0 : _d.merchandising) && !((_f = (_e = search === null || search === void 0 ? void 0 : search.response) === null || _e === void 0 ? void 0 : _e.filters) === null || _f === void 0 ? void 0 : _f.length) && !searchStore.loaded) {
                            window.location.replace(redirectURL);
                            return [2 /*return*/, false];
                        }
                        nonBackgroundFilters = (_h = (_g = search === null || search === void 0 ? void 0 : search.request) === null || _g === void 0 ? void 0 : _g.filters) === null || _h === void 0 ? void 0 : _h.filter(function (filter) { return !filter.background; });
                        if (((_k = (_j = config === null || config === void 0 ? void 0 : config.settings) === null || _j === void 0 ? void 0 : _j.redirects) === null || _k === void 0 ? void 0 : _k.singleResult) &&
                            ((_m = (_l = search === null || search === void 0 ? void 0 : search.response) === null || _l === void 0 ? void 0 : _l.search) === null || _m === void 0 ? void 0 : _m.query) &&
                            ((_p = (_o = search === null || search === void 0 ? void 0 : search.response) === null || _o === void 0 ? void 0 : _o.pagination) === null || _p === void 0 ? void 0 : _p.totalResults) === 1 &&
                            !(nonBackgroundFilters === null || nonBackgroundFilters === void 0 ? void 0 : nonBackgroundFilters.length) &&
                            !search.controller.previousResults.length) {
                            window.location.replace(search === null || search === void 0 ? void 0 : search.response.results[0].mappings.core.url);
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, next()];
                    case 1:
                        _q.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        _this.eventManager.on('afterStore', function (search, next) { return __awaiter(_this, void 0, void 0, function () {
            var storableRequestParams, stringyParams, scrollMap, elementPosition;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, next()];
                    case 1:
                        _a.sent();
                        // save last params
                        this.storage.set('lastStringyParams', JSON.stringify(search.request));
                        storableRequestParams = getStorableRequestParams(search.request);
                        stringyParams = JSON.stringify(storableRequestParams);
                        scrollMap = this.storage.get('scrollMap') || {};
                        elementPosition = scrollMap[stringyParams];
                        if (!elementPosition) {
                            // search params have changed - empty the scrollMap
                            this.storage.set('scrollMap', {});
                        }
                        return [4 /*yield*/, this.eventManager.fire('restorePosition', { controller: this, element: elementPosition })];
                    case 2:
                        _a.sent();
                        search.controller.store.loading = false;
                        return [2 /*return*/];
                }
            });
        }); });
        // restore position
        if ((_d = (_c = _this.config.settings) === null || _c === void 0 ? void 0 : _c.restorePosition) === null || _d === void 0 ? void 0 : _d.enabled) {
            _this.eventManager.on('restorePosition', function (_a, next) {
                var controller = _a.controller, element = _a.element;
                return __awaiter(_this, void 0, void 0, function () {
                    var scrollToPosition;
                    var _this = this;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                scrollToPosition = function () {
                                    return new Promise(function (resolve) { return __awaiter(_this, void 0, void 0, function () {
                                        var maxCheckTime, checkTime, maxScrolls, maxCheckCount, scrollBackCount, checkCount, scrolledElem, checkAndScroll;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0:
                                                    maxCheckTime = 500;
                                                    checkTime = 50;
                                                    maxScrolls = Math.ceil(maxCheckTime / checkTime);
                                                    maxCheckCount = maxScrolls + 2;
                                                    scrollBackCount = 0;
                                                    checkCount = 0;
                                                    scrolledElem = undefined;
                                                    checkAndScroll = function () {
                                                        var _a;
                                                        var offset = ((_a = element === null || element === void 0 ? void 0 : element.domRect) === null || _a === void 0 ? void 0 : _a.top) || 0;
                                                        var elem = document.querySelector(element === null || element === void 0 ? void 0 : element.selector);
                                                        // for case where the element clicked on has no height
                                                        while (elem && !elem.getBoundingClientRect().height) {
                                                            elem = elem.parentElement;
                                                            // original offset no longer applies since using different element
                                                            offset = 0;
                                                        }
                                                        if (elem) {
                                                            var y = elem.getBoundingClientRect().y;
                                                            scrollBackCount++;
                                                            // if the offset is off, we need to scroll into position (can be caused by lazy loaded images)
                                                            if (y > offset + 1 || y < offset - 1) {
                                                                window.scrollBy(0, y - offset);
                                                            }
                                                            else {
                                                                // don't need to scroll - it is right where we want it
                                                                scrolledElem = elem;
                                                            }
                                                        }
                                                        else {
                                                            checkCount++;
                                                        }
                                                        return true;
                                                    };
                                                    _a.label = 1;
                                                case 1:
                                                    if (!(checkAndScroll() && scrollBackCount <= maxScrolls && checkCount <= maxCheckCount)) return [3 /*break*/, 3];
                                                    return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, checkTime); })];
                                                case 2:
                                                    _a.sent();
                                                    return [3 /*break*/, 1];
                                                case 3:
                                                    if (scrolledElem) {
                                                        controller.log.debug('restored position to: ', scrolledElem);
                                                    }
                                                    else {
                                                        controller.log.debug('attempted to scroll back to element with selector: ', element === null || element === void 0 ? void 0 : element.selector);
                                                    }
                                                    resolve();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                };
                                if (!element) return [3 /*break*/, 2];
                                return [4 /*yield*/, scrollToPosition()];
                            case 1:
                                _b.sent();
                                _b.label = 2;
                            case 2: return [4 /*yield*/, next()];
                            case 3:
                                _b.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            });
        }
        // attach config plugins and event middleware
        _this.use(_this.config);
        return _this;
    }
    Object.defineProperty(SearchController.prototype, "params", {
        get: function () {
            var _a, _b, _c, _d;
            var params = (0, deepmerge_1.default)(__assign({}, (0, getParams_1.getSearchParams)(this.urlManager.state)), this.config.globals || {});
            // redirect setting
            if (!((_b = (_a = this.config.settings) === null || _a === void 0 ? void 0 : _a.redirects) === null || _b === void 0 ? void 0 : _b.merchandising) || this.store.loaded) {
                params.search = params.search || {};
                params.search.redirectResponse = 'full';
            }
            params.tracking = params.tracking || {};
            params.tracking.domain = window.location.href;
            var userId = this.tracker.getUserId();
            if (userId) {
                params.tracking.userId = userId;
            }
            var sessionId = this.tracker.getContext().sessionId;
            if (sessionId) {
                params.tracking.sessionId = sessionId;
            }
            var pageId = this.tracker.getContext().pageLoadId;
            if (pageId) {
                params.tracking.pageLoadId = pageId;
            }
            if (!((_d = (_c = this.config.globals) === null || _c === void 0 ? void 0 : _c.personalization) === null || _d === void 0 ? void 0 : _d.disabled)) {
                var cartItems = this.tracker.cookies.cart.get();
                if (cartItems.length) {
                    params.personalization = params.personalization || {};
                    params.personalization.cart = cartItems.join(',');
                }
                var lastViewedItems = this.tracker.cookies.viewed.get();
                if (lastViewedItems.length) {
                    params.personalization = params.personalization || {};
                    params.personalization.lastViewed = lastViewedItems.join(',');
                }
                var shopperId = this.tracker.getShopperId();
                if (shopperId) {
                    params.personalization = params.personalization || {};
                    params.personalization.shopper = shopperId;
                }
            }
            return params;
        },
        enumerable: false,
        configurable: true
    });
    return SearchController;
}(AbstractController_1.AbstractController));
exports.SearchController = SearchController;
function getStorableRequestParams(request) {
    var _a, _b, _c, _d;
    return {
        siteId: request.siteId,
        sorts: request.sorts,
        search: {
            query: {
                string: ((_b = (_a = request === null || request === void 0 ? void 0 : request.search) === null || _a === void 0 ? void 0 : _a.query) === null || _b === void 0 ? void 0 : _b.string) || '',
            },
            subQuery: ((_c = request === null || request === void 0 ? void 0 : request.search) === null || _c === void 0 ? void 0 : _c.subQuery) || '',
        },
        filters: request.filters,
        pagination: request.pagination,
        facets: request.facets,
        merchandising: {
            landingPage: ((_d = request.merchandising) === null || _d === void 0 ? void 0 : _d.landingPage) || '',
        },
    };
}
exports.getStorableRequestParams = getStorableRequestParams;
function generateHrefSelector(element, href, levels) {
    if (levels === void 0) { levels = 7; }
    var level = 0;
    var elem = element;
    while (elem && level <= levels) {
        // check within
        var innerHrefElem = elem.querySelector("[href*=\"".concat(href, "\"]"));
        if (innerHrefElem) {
            // innerHrefElem was found! now get selectors up to elem that contained it
            var selector = '';
            var parentElem = innerHrefElem;
            while (parentElem && parentElem != elem.parentElement) {
                var classNames = parentElem.classList.value.trim().split(' ');
                // document.querySelector does not appreciate special characters - must escape them
                var escapedClassSelector = classNames.reduce(function (classes, classname) { return (classname.trim() ? "".concat(classes, ".").concat((0, css_escape_1.default)(classname.trim())) : classes); }, '');
                selector = "".concat(parentElem.tagName).concat(escapedClassSelector).concat(selector ? " ".concat(selector) : '');
                parentElem = parentElem.parentElement;
            }
            return "".concat(selector, "[href*=\"").concat(href, "\"]");
        }
        elem = elem.parentElement;
        level++;
    }
    return;
}
exports.generateHrefSelector = generateHrefSelector;
function backFillSize(pages, pageSize) {
    var totalResults = pages * pageSize;
    var numPages = Math.ceil(totalResults / API_LIMIT);
    while (totalResults % numPages)
        numPages++;
    return { size: totalResults / numPages, pages: numPages };
}
